 ‚úÖ Given Question:
 You're given a binary tree.
 Your task is to compute:
     - The *Top View* of the binary tree: nodes visible from the top.
     - The *Bottom View* of the binary tree: nodes visible from the bottom.
     - The *Right View* of the binary tree: nodes visible from the right.
     - The *Left View* of the binary tree: nodes visible from the left.

 ‚úÖ Given Data:
 You have:
     - A binary tree with nodes of type `Node`.
     - A `Tuple` or `Pair` class that pairs:
         - A `Node` (tree node).
         - An `int` column (for horizontal distance or level).
     - Methods implemented using:
         - BFS for Top, Bottom, Left (variation 1), and Right views.
         - DFS for Left (variation 2) and Right views.

 ------------------------------------------------------------
 üåê Approach for Top and Bottom Views:
 ------------------------------------------------------------

 ‚úÖ Intuition:
 For both views, imagine vertical lines drawn through the tree.
 Each vertical line represents a *column index* (or horizontal distance from the root).
 Use **BFS (level-order traversal)** to explore nodes layer by layer, while tracking column indices.

 ‚ñ∂ For Top View:
     - We want the *first* node encountered at each column.

 ‚ñ∂ For Bottom View:
     - We want the *last* node encountered at each column.

 ‚úÖ Common Setup:
     - If the tree is empty, return an empty list.
     - Initialize a `TreeMap<Integer, Integer>` to hold column index ‚Üí node value.
         - TreeMap keeps keys sorted for left-to-right ordering.
     - Initialize a `Queue<Tuple>` to perform BFS traversal.
     - Enqueue the root node with column 0.

 ‚úÖ BFS Traversal Loop:
     - While the queue is not empty:
         - Dequeue the current `Tuple` containing:
             - `node`: the current tree node.
             - `column`: its horizontal distance from root.

         ‚ñ∂ Top View Logic:
             - If `column` is *not already* in the map:
                 - Add `node.data` to the map (first seen at this column).

         ‚ñ∂ Bottom View Logic:
             - Always insert/overwrite `node.data` at `column` in the map.
                 - This way, the last node seen at each column remains in the map.

         - If `node.left` exists:
             - Enqueue it with `column - 1`.

         - If `node.right` exists:
             - Enqueue it with `column + 1`.

 ‚úÖ Final Step:
     - Return the values from the TreeMap as a list.
         - These represent either the top or bottom view, sorted left to right.

 üïí Time Complexity:
     - O(n log n), where n = number of nodes.
         - Each TreeMap insertion/lookup is O(log n).
         - Each node is visited once in BFS.

 üß† Space Complexity:
     - O(n) for TreeMap and Queue, which may grow to hold all nodes in the tree.

 ------------------------------------------------------------
 üëÅÔ∏è Approach for Left and Right Views:
 ------------------------------------------------------------

 ‚úÖ Intuition:
 For left and right views, imagine standing on the side of the tree.
 At each depth/level of the tree, you can only see the *first* node (left view) or *last* node (right view) visible from that side.

 -----------------------------------
 ‚úÖ BFS Approach (Level-Order):
 -----------------------------------

 ‚ñ∂ Left View (BFS):
     - Traverse the tree level by level using a queue.
     - At each level, add the *first* node you encounter to the result.
     - Uses a `Map<Integer, Integer>` to store level ‚Üí node value.
     - Only insert into the map if the level key is missing.

 ‚ñ∂ Right View (BFS):
     - Similar logic to left view, but prioritize the *last* node seen at each level.
     - Can reverse the order of children enqueued (right first) or overwrite existing map entries.

 üïí Time Complexity: O(n)
 üß† Space Complexity: O(n)

 -----------------------------------
 ‚úÖ DFS Approach (Preorder Traversal):
 -----------------------------------

 ‚ñ∂ Left View (DFS):
     - Traverse the tree using DFS, prioritizing **left** children.
     - At each level, if it's the first time visiting that level (`list.size() == level`), add the node‚Äôs value.
     - Recurse: left first, then right.

 ‚ñ∂ Right View (DFS):
     - Traverse the tree using DFS, prioritizing **right** children.
     - At each level, if it's the first time visiting that level (`list.size() == level`), add the node‚Äôs value.
     - Recurse: right first, then left.

 ‚úÖ Benefit of DFS:
     - Cleaner implementation using recursion.
     - Only requires a list and current level as parameters.

 üïí Time Complexity: O(n)
 üß† Space Complexity: O(h), where h is the height of the tree (due to recursion stack).
