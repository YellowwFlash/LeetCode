âœ… Given Question:
Design an algorithm that calculates the stock span of a stock's price for each day.
The stock span is the number of consecutive days (including today) the stock price has been less than or equal to todayâ€™s price.

âœ… Given Data:
  - A stream of stock prices (one at a time)
  - For each price, return the span (number of days including today)
    âž¤ Such that the price was less than or equal to todayâ€™s price.

âœ… Intuition:
This is a classic monotonic stack problem.
We maintain a stack of price + span pairs. The idea is:
  - If the current price is greater than or equal to the price on top of the stack,
    âž¤ Pop and accumulate the span of those days.
  - We continue this until we find a higher price or the stack becomes empty.
  - This gives us the number of days (including today) the price has been rising or staying the same.

------------------------------------------------------
Approach-1: Stack of [Price, Span]
------------------------------------------------------
ðŸ”¹ Class: `OnlineStockSpan`
  - Maintains a stack of pairs: [price, span]

ðŸ”¹ Method: `next(int price)`
Steps:
  1. Start with `span = 1` for the current price.
  2. While the stack is not empty and the top price is less than or equal to current price:
     - Pop the top
     - Add its span to the current span
  3. Push the current price and its total span onto the stack.
  4. Return the span.

âœ… Why Stack Works:
- We only keep prices on the stack that are greater than the current price.
- When a lower or equal price is encountered, we can combine the spans of previous prices.
- This gives us an efficient way to track consecutive days with prices â‰¤ current.

âœ… Time Complexity:
  - Amortized O(1) per `next()` call
    âž¤ Each price is pushed and popped from the stack only once.

âœ… Space Complexity:
  - O(n) for the stack in the worst case (monotonically decreasing prices)

ðŸ”¹ Example:
  Inputs: [100, 80, 60, 70, 60, 75, 85]
  
  Step-by-step:
    - 100 â†’ span = 1   â†’ stack: [100,1]
    - 80  â†’ span = 1   â†’ stack: [100,1], [80,1]
    - 60  â†’ span = 1   â†’ stack: [100,1], [80,1], [60,1]
    - 70  â†’ pop [60,1] â†’ span = 2 â†’ stack: [100,1], [80,1], [70,2]
    - 60  â†’ span = 1   â†’ stack: [100,1], [80,1], [70,2], [60,1]
    - 75  â†’ pop [60,1], [70,2] â†’ span = 4 â†’ stack: [100,1], [80,1], [75,4]
    - 85  â†’ pop [75,4], [80,1] â†’ span = 6 â†’ stack: [100,1], [85,6]

  Output: [1, 1, 1, 2, 1, 4, 6]

ðŸ”¹ Edge Cases:
  - Very first price â†’ always returns 1
  - All increasing prices â†’ span grows linearly
  - All decreasing prices â†’ span is always 1
