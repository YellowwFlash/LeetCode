âœ… Given Question:
Given a binary array `nums`, return the maximum number of consecutive 1s in the array.
In an advanced version, you're allowed to flip at most `k` zeros to ones and return
the maximum length of such a subarray.

âœ… Given Data:
  - `nums`: An array of 0s and 1s
  - Optional: Integer `k` (number of 0s you are allowed to flip)

âœ… Intuition:
We want to find the longest contiguous subarray of 1s.
  âž¤ In the basic version (no flipping), we simply count stretches of 1s.
  âž¤ In the advanced version (with `k` flips allowed), we use a sliding window approach:
     - Track how many 0s are in the current window.
     - Shrink the window when the number of 0s exceeds `k`.

------------------------------------------------------
Approach-1: Counting Consecutive 1s
------------------------------------------------------
ðŸ”¹ Method: `maxConsecutiveOnes(int[] nums)`
Steps:
  1. Initialize `count = 0`, `max = 0`.
  2. Iterate over the array:
     - If `nums[i] == 1`, increment `count`.
     - If `nums[i] == 0`, update `max = Math.max(max, count)` and reset `count = 0`.
  3. At the end, return `Math.max(count, max)` to handle cases where the array ends with 1s.

âœ… Time Complexity:
  - O(n), where n = length of the array

âœ… Space Complexity:
  - O(1)

ðŸ”¹ Example:
  nums = [1, 1, 0, 1, 1, 1]
  âž¤ Counts: 2 (before 0), then reset, then 3 â†’ max = 3

------------------------------------------------------
Approach-2: Sliding Window with `k` Zero Flips
------------------------------------------------------
ðŸ”¹ Method: `maxConsecutiveOnesII(int[] nums, int k)`
Steps:
  1. Initialize `left = 0`, `right = 0`, `zeros = 0`, `maxLength = 0`.
  2. Expand the `right` pointer:
     - If `nums[right] == 0`, increment `zeros`.
     - If `zeros > k`, shrink the window from the `left`:
        âž¤ While `zeros > k`, move `left` forward and decrement `zeros` if `nums[left] == 0`.
  3. At each step, calculate the window size: `right - left + 1`.
     - Update `maxLength` accordingly.
  4. Return `maxLength`.

âœ… Time Complexity:
  - O(n), where n = length of the array

âœ… Space Complexity:
  - O(1)

ðŸ”¹ Example:
  nums = [1,0,1,1,0], k = 1
  âž¤ Flip one 0 â†’ longest 1s = 4 ([1,1,1,1])

ðŸ”¹ Edge Cases:
  - All 1s â†’ returns entire array length
  - All 0s â†’ returns 0 (or `k`, if flips are allowed)
  - Empty array â†’ returns 0
  - k = 0 â†’ behaves like Approach-1
