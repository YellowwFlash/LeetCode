âœ… Given Question:
Given a binary array `nums[]` and an integer `goal`, return the number of subarrays
whose elements sum up exactly to `goal`.

âœ… Given Data:
  - `nums[]`: Array of 0s and 1s
  - `goal`: Target sum
  - Task: Count the number of contiguous subarrays that sum to exactly `goal`

âœ… Intuition:
This is a subarray sum equals K problem.
There are two optimized approaches to solve it efficiently:

  1ï¸âƒ£ Prefix Sum + HashMap â†’ General solution (works for any array, not just binary)
  2ï¸âƒ£ AtMost Technique â†’ Optimized for binary arrays only (0s and 1s)

------------------------------------------------------
Approach-1: Prefix Sum + HashMap
------------------------------------------------------
ğŸ”¹ Method: `countBinarySubarraysHashMap(int[] nums, int goal)`
Steps:
  1. Use a `prefix` sum to accumulate values.
  2. Maintain a `HashMap<prefix_sum, frequency>` to count previous sums.
     â¤ This helps to detect subarrays that sum to `goal`.
  3. At each index:
     - Compute `prefix += nums[i]`
     - Let `remainder = prefix - goal`
     - If `remainder` is in the map, add its frequency to the answer
     - Update the map with the current prefix sum

âœ… Why it works:
  â¤ If `prefix[j] - prefix[i] = goal`, then the subarray from `i` to `j-1` sums to goal.
     The map tracks how many times such `prefix[i]` occurred before.

âœ… Time Complexity:
  - O(n), where n = length of the array

âœ… Space Complexity:
  - O(n) for the HashMap

ğŸ”¹ Example:
  nums = [1,0,1,0,1], goal = 2
  Valid subarrays: [1,0,1], [0,1,0,1], [1,0,1] â†’ count = 4

------------------------------------------------------
Approach-2: AtMost Sliding Window (Only for Binary Arrays)
------------------------------------------------------
ğŸ”¹ Method: `countBinarySubarraysAtmost(int[] nums, int goal)`
Idea:
  - Count subarrays with sum â‰¤ goal (`atMost(goal)`)
  - Count subarrays with sum â‰¤ goal - 1 (`atMost(goal - 1)`)
  - Their difference is the number of subarrays with sum = goal

Formula:
  â¤ countExactly(goal) = atMost(goal) - atMost(goal - 1)

ğŸ”¹ Helper Method: `atmost(nums, goal)`
Steps:
  1. Use two pointers (`left`, `right`) and a running sum
  2. Expand `right` and add to `sum`
  3. While `sum > goal`, move `left` forward and subtract values
  4. At each step, add `right - left + 1` to count (number of valid subarrays ending at `right`)

âœ… Time Complexity:
  - O(n), since each element is processed at most twice

âœ… Space Complexity:
  - O(1)

ğŸ”¹ Why this works for binary arrays only:
  - Binary arrays have simple sum behavior (values are 0 or 1)
  - Guarantees that all subarrays with a sum â‰¤ goal are contiguous and easy to count

ğŸ”¹ Example:
  nums = [1,0,1,0,1], goal = 2
  â¤ atMost(2) = 10, atMost(1) = 6 â†’ count = 10 - 6 = 4

------------------------------------------------------
âœ… Final Summary:
- Prefix Sum + HashMap works for any array (not just binary)
- AtMost Technique is highly efficient but works only on binary arrays
- Both run in O(n) time, but use different strategies:
   â¤ HashMap counts subarrays via previous prefix sums
   â¤ Sliding window counts "at most" and uses subtraction trick

ğŸ”¹ Edge Cases:
  - Empty array â†’ return 0
  - goal = 0 â†’ count subarrays with only 0s
  - goal > total sum â†’ return 0
  - All 1s or all 0s â†’ still works in both approaches
