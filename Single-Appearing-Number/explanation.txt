âœ… Given Question:
Given a non-empty array of integers `arr`, every element appears exactly twice except for one element, which appears only once. Return that single element.

âœ… Given Data:
An integer array int[] nums where:
    - All elements appear twice except for one unique element that appears once.
    - Array is non-empty.
    - In some cases, the array is sorted (especially for the binary search approach).

âœ… Intuition:
The problem asks us to find the element that is not repeated in an array where all others appear exactly twice.

This can be solved using three main approaches:
1. A frequency map using HashMap (intuitive and easy to understand).
2. Bit manipulation using XOR (optimized and clever).
3. Modified binary search for sorted arrays (efficient and tricky to derive).

-----------------------------------
Approach-1: Using HashMap (Intuitive Approach)
-----------------------------------
    - Create a HashMap to store the frequency of each number.
    - Traverse the array:
        - For each number, update its frequency in the map using map.getOrDefault().
    - After building the frequency map, traverse its entries:
        - Return the key (number) with value equal to 1.

    Time Complexity:
        - O(n) for building the map
        - O(n) for scanning the map
        - Total: O(n)

    Space Complexity:
        - O(n) for the map

    Note:
        - This approach is simple and intuitive but requires extra space.
        - It works well for small inputs or when readability is important.

-----------------------------------
Approach-2: Using XOR Operator (Optimized Approach)
-----------------------------------
    - Initialize result = 0.
    - Traverse the array:
        - XOR each number with result.
        - Use the property: a ^ a = 0 and a ^ 0 = a
    - After the loop, result holds the number that appears once.

    Time Complexity:
        - O(n), single pass through the array

    Space Complexity:
        - O(1), no extra space used

    Note:
        - This approach is space-efficient and fast.
        - It relies on XOR properties and is harder to derive intuitively but performs better.

-----------------------------------------------------------------------
Approach-3: Using Modified Binary Search (For Sorted Arrays Only)
-----------------------------------------------------------------------
    âœ… Key Observation:
        - All elements before the single element follow the pattern: [even index] == [even + 1]
        â†’ Example: 1, 1 â†’ indexes 0 and 1  
        - All elements after the single element follow the pattern: [odd index] == [odd + 1]
        â†’ Because the single element shifted the pattern by one place

    âœ… Simple Example:
    nums = [1, 1, 2, 3, 3, 4, 4]

    - Indexes:  0  1  2  3  4  5  6
    - Elements: 1  1  2  3  3  4  4
    - Observe:
        - Pairs at (0,1), (3,4), (5,6) â†’ all good
        - But index 2 (value 2) stands alone â†’ This is the single element

    âœ… How Binary Search Helps:
        - Use binary search to check mid-index and its neighbors.
        - Decide which half of the array to search next based on how pairing behaves at mid.

    âœ… How to Eliminate Halves:
        1. Check if mid is even:
            - If `nums[mid] == nums[mid + 1]`, the left part up to mid is perfectly paired â†’ single element must be on the right.
            - Else, the pairing is broken â†’ single element is on the left (including mid).

        2. Check if mid is odd:
            - If `nums[mid] == nums[mid - 1]`, the left part is still valid â†’ search in the right half.
            - Else, the pairing is broken â†’ single element is on the left half.

    âœ… Why This Works:
        - Before the single element: pairs are in even-odd positions (0-1, 2-3, â€¦)
        - After the single element: everything shifts â†’ now pairs are in odd-even (3-4, 5-6, â€¦)
        - Using this pattern, you eliminate half of the array at every step!

    âœ… Time Complexity:
        - O(log n) â€” efficient due to binary search

    âœ… Space Complexity:
        - O(1) â€” no extra space used


------------------------------------------------------
âœ… Approach-4: XOR (When two elements appear once, all others twice)
------------------------------------------------------

âœ… Problem Statement:
You are given an integer array where exactly two elements appear once, 
and all other elements appear exactly twice. Return the two unique elements.

âœ… Intuition:
XOR has the property: 
    - a ^ a = 0 (duplicate elements cancel out)
    - 0 ^ a = a

If we XOR the entire array:
    - All elements that appear twice will cancel out to 0
    - We're left with xor = num1 ^ num2 (the two unique elements)

But we canâ€™t directly extract num1 and num2 from their XOR.
So, we use the rightmost set bit in xor to split the array into two groups:
    - One group has this bit set
    - One group has this bit unset

This ensures num1 and num2 go into different groups (since they differ at that bit),
while duplicates still cancel out within their groups.

âœ… Example:
nums = [2, 4, 7, 9, 2, 4]

Step 1: XOR all numbers  
â†’ 2 ^ 4 ^ 7 ^ 9 ^ 2 ^ 4 = (2 ^ 2) ^ (4 ^ 4) ^ (7 ^ 9) = 0 ^ 0 ^ 14 = 14  
So, xor = 14 = 1110 (in binary)

Step 2: Find rightmost set bit in xor â†’ `rightmostSetBit = xor & -xor`
â†’ 14 = 1110 â†’ rightmostSetBit = 0010 (which is bit position 1)

Step 3: Divide nums into two groups:
- Group 1 (bit 1 is set): 2 (0010), 2 (0010), 7 (0111) â†’ XOR gives 7
- Group 2 (bit 1 is not set): 4 (0100), 4 (0100), 9 (1001) â†’ XOR gives 9

âœ… Output: [7, 9] (Order doesn't matter)

âœ… Time Complexity Breakdown:
1. XOR all elements â†’ takes O(n) time  
   - One pass through the array â†’ n operations

2. Find rightmost set bit â†’ O(1) operation  
   - Bitwise calculation

3. Traverse array again to partition and XOR groups â†’ O(n) time  
   - Another full pass â†’ n operations

ðŸ“Œ Total time:  
â†’ First pass (XOR all nums) = n operations  
â†’ Second pass (split groups and XOR) = n operations  
â†’ Total = 2n operations â†’ O(n)

âœ… Space Complexity:
â†’ O(1) â€” No extra space except a few integer variables

âœ… Summary:
This is the most optimal approach when exactly two elements appear once.
It uses pure bitwise operations with two passes over the array, no extra memory.

Elegant, fast, and powerful â€” especially for large arrays.
