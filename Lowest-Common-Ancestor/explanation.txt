 ‚úÖ Problem:
 Given a binary tree and two node values `n1` and `n2`,
 your task is to find their Lowest Common Ancestor (LCA).

 The LCA of two nodes is defined as the deepest node that has both `n1` and `n2` as descendants.
 A node can also be a descendant of itself.

 ------------------------------------------------------------
 üåê Approach 1: Using Paths (Backtracking)
 ------------------------------------------------------------

 ‚úÖ Intuition:
 - The idea is to find the path from root to `n1` and the path from root to `n2`.
 - Then, compare the two paths to find the last common node in both.

 ‚úÖ Steps:
 1. Use a helper function `findPath` to collect the path from root to each target node in a list.
 2. If either path is not found (i.e., the node doesn‚Äôt exist in the tree), return `-1`.
 3. Compare the two paths and identify the last common node ‚Äî that's the LCA.

 ‚úÖ Key Details:
 - `findPath` uses recursion and backtracking.
 - It adds each visited node to the path list and removes it if the path is not valid (backtracking).
 - Comparing paths with `contains()` makes this solution less efficient.

 ‚úÖ Time Complexity:
 - O(n¬≤) in the worst case:
     - Each `contains()` call inside the loop is O(n), making nested iterations O(n¬≤).

 ‚úÖ Space Complexity:
 - O(n) for storing each path (in the worst case, for skewed trees).

 ‚úÖ Example:
          1
         / \
        2   3
       / \
      4   5
  - LCA(4, 5) = 2
  - Path to 4: [1, 2, 4]
  - Path to 5: [1, 2, 5]
  - Last common element: 2

 ------------------------------------------------------------
 üåê Approach 2: Using Simple DFS (Optimal for Binary Trees)
 ------------------------------------------------------------

 ‚úÖ Intuition:
 - Traverse the tree from the root.
 - If either `n1` or `n2` matches the current node, return that node.
 - Recursively search left and right subtrees for the targets.
 - If both left and right recursive calls return non-null, current node is the LCA.

 ‚úÖ Steps:
 1. If root is null, return null.
 2. If root matches `n1` or `n2`, return root.
 3. Recurse into left and right subtrees.
 4. If both return non-null, current node is LCA.
 5. Otherwise, return the non-null subtree result.

 ‚úÖ Time Complexity:
 - O(n): each node is visited once.

 ‚úÖ Space Complexity:
 - O(h), where h is the height of the tree (for recursion stack).
   - Worst case: O(n) for skewed tree.
   - Best case: O(log n) for balanced tree.

 ‚úÖ Example:
          1
         / \
        2   3
       / \
      4   5
  - LCA(4, 5) = 2

 ------------------------------------------------------------
 üåê Variation: Optimized for Binary Search Tree (BST)
 ------------------------------------------------------------

 ‚úÖ Intuition:
 - In a BST, for any node:
     - Left subtree contains smaller values.
     - Right subtree contains larger values.
 - So, we can use this property to locate LCA without full traversal.

 ‚úÖ Steps:
 1. Start at the root node.
 2. If both `n1` and `n2` are less than current node, LCA lies in left subtree.
 3. If both are greater, LCA lies in right subtree.
 4. If they split across the current node, current node is the LCA.

 ‚úÖ Time Complexity:
 - O(h), where h = height of the BST.
   - O(log n) for balanced BST.
   - O(n) for skewed BST.

 ‚úÖ Space Complexity:
 - O(h) due to recursion stack (same as time complexity).

 ‚úÖ Example:
          20
         /  \
       10    30
      /  \     \
     5   15     40
  - LCA(5, 15) = 10
  - LCA(5, 30) = 20
 