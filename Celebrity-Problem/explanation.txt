âœ… Given Question:
You are given a matrix M[][] of size n x n where M[i][j] == 1 means person i knows person j,
and M[i][j] == 0 means person i does NOT know person j.
A celebrity is defined as someone who:
  âž¤ Is known by everyone (n - 1 people)
  âž¤ Knows no one (not even one person)

You need to return the index of the celebrity if there is one; otherwise, return -1.

âœ… Given Data:
  - M: 2D array of integers (0 or 1) representing who knows whom
  - n: Number of people at the party

âœ… Intuition:
A celebrity is someone who is a universal recipient of knowledge (everyone knows them),
but they donâ€™t reciprocate it (they know no one). Two main checks:
  - Row i: all 0s (person i knows no one)
  - Column i: all 1s except M[i][i] (everyone knows person i)

We implement two approaches:

------------------------------------------------------
Approach-1: Using iKnow and uKnow Arrays
------------------------------------------------------
ðŸ”¹ Method: `celebrity(int[][] M, int n)`
Steps:
  1. Initialize two arrays:
     - `iKnow[i]`: Number of people person i knows
     - `uKnow[i]`: Number of people who know person i
  2. Iterate through the matrix:
     - If M[i][j] == 1 â†’ person i knows person j
       âž¤ Increment iKnow[i]
       âž¤ Increment uKnow[j]
  3. After filling both arrays:
     - Check for a person `i` such that:
       âž¤ iKnow[i] == 0 (they know no one)
       âž¤ uKnow[i] == n - 1 (everyone else knows them)
     - If found, return `i` as the celebrity
     - Otherwise, return -1

âœ… Time Complexity:
  - O(n^2) for traversing the entire matrix

âœ… Space Complexity:
  - O(n) for the two arrays

ðŸ”¹ Example:
    M = [ [0, 1, 1],
          [0, 0, 1],
          [0, 0, 0] ]
    âž¤ iKnow = [2, 1, 0]
    âž¤ uKnow = [0, 1, 2]
    Person 2 knows no one and is known by everyone â†’ Celebrity = 2

------------------------------------------------------
Approach-2: Two-Pointer Elimination (Optimized)
------------------------------------------------------
ðŸ”¹ Method: `celebrityPointers(int[][] M, int n)`
Steps:
  1. Use two pointers: `top = 0`, `down = n - 1`
  2. While top < down:
     - If M[top][down] == 1:
       âž¤ top knows down â†’ top cannot be celebrity â†’ move top++
     - Else:
       âž¤ top does not know down â†’ down cannot be celebrity â†’ move down--
     - This reduces the search space efficiently
  3. Candidate left is `top` (or `down`)
  4. Validate the candidate:
     - For all `i != top`, ensure:
       âž¤ M[top][i] == 0 (top knows no one)
       âž¤ M[i][top] == 1 (everyone knows top)
     - If any condition fails â†’ return -1

âœ… Time Complexity:
  - O(n) for candidate elimination
  - O(n) for validation
  - Overall: O(n)

âœ… Space Complexity:
  - O(1), no extra space used

ðŸ”¹ Example:
    M = [ [0, 1, 1],
          [0, 0, 1],
          [0, 0, 0] ]
    âž¤ Step 1: top = 0, down = 2
    âž¤ M[0][2] == 1 â†’ top++
    âž¤ M[1][2] == 1 â†’ top++
    âž¤ Now top == 2, candidate
    âž¤ Validate: row 2 is all 0s, column 2 is all 1s except M[2][2] â†’ Valid â†’ Return 2

ðŸ”¹ Final Summary:
- Approach-1 is easier to implement but takes O(n^2) time.
- Approach-2 is more optimal (O(n)) by using elimination logic and verifying only one candidate.
- Both methods ensure correct detection of the celebrity if one exists.

ðŸ”¹ Edge Cases:
  - No person satisfies the condition â†’ return -1
  - Multiple candidates but only one true celebrity â†’ works correctly
  - Self-knowledge (M[i][i] can be 0 or 1) â†’ irrelevant in logic