 ✅ Given Question:
 You're given `numCourses` and a list of `prerequisites` where:
     - Each prerequisite is a pair [a, b], meaning course `a` requires course `b` to be completed first.
 
 There are two tasks (variations):

     ➤ Variation-1:
         - Determine if it’s possible to complete **all** courses.
         - Return `true` if yes, otherwise `false`.

     ➤ Variation-2:
         - Return a **valid order** of course completion.
         - If it’s impossible (due to cycle), return an empty list.

 ✅ Given Data:
 You have:
     - An integer `numCourses` representing total courses (0 to numCourses-1).
     - A list of prerequisites.
     - You must use a **BFS-based topological sorting** approach (Kahn’s algorithm):
         - An adjacency list to represent the graph.
         - An `indegree[]` array to track number of prerequisites for each course.
         - A `queue` to process nodes with 0 indegree.

 ✅ Intuition:
 The course dependency graph is a **DAG (if solvable)**:
     - A course can only be taken after its prerequisites are completed.
     - If we can topologically sort all courses → All courses are possible.
     - If a **cycle exists**, at least one course cannot be completed.

 ------------------------------------------------------------
 Variation-1: Check if All Courses Can Be Finished
 ------------------------------------------------------------
     - Step 1: Build the graph:
         - Use an adjacency list `graph` to store prerequisites.
         - Use an `indegree[]` array to count prerequisites for each course.
     - Step 2: Add all courses with indegree 0 to the queue.
     - Step 3: Perform BFS:
         - Remove a course from the queue.
         - Increase a `completed` counter.
         - For each dependent course:
             - Reduce its indegree.
             - If indegree becomes 0, add it to the queue.
     - Step 4: At the end:
         - If `completed == numCourses`, return `true` (all courses possible).
         - Else, return `false` (cycle exists).

 ✅ 🔍 Deep Dive (isPossible):
     - ✅ Courses with no prerequisites are safe to take first.
     - ✅ BFS reduces the dependency chain layer by layer.
     - ❌ If a course never reaches indegree 0 → part of a cycle → cannot complete all.

 ------------------------------------------------------------
 Variation-2: Return a Valid Course Order
 ------------------------------------------------------------
     - Step 1: Build the graph and indegree array (same as above).
     - Step 2: Enqueue all nodes with indegree 0.
     - Step 3: Perform BFS:
         - Poll a course and add to `order` list.
         - For each dependent course:
             - Decrease indegree.
             - If indegree is 0, enqueue it.
     - Step 4: Final Check:
         - If `order.size() == numCourses` → valid order → return `order`.
         - Else → cycle exists → return empty list.

 ✅ 🔍 Deep Dive (findOrder):
     - ✅ Maintains correct course execution order.
     - ✅ Any topological ordering is valid if no cycle exists.
     - ❌ If not all nodes are processed, a cycle prevents valid ordering.

 🕒 Time Complexity (Both Variations):
     - O(V + E) where:
         - V = number of courses (`numCourses`)
         - E = number of prerequisites

 🧠 Space Complexity (Both Variations):
     - O(V + E):
         - For the adjacency list (`graph`) and other helper structures.
