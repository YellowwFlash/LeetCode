 ✅ Given Question:
 You are given a graph represented as an adjacency list (`List<List<Integer>> graph`).
 Your task is to detect whether the graph contains a cycle.

 You need to handle:
     - Undirected graphs (detect cycles using BFS and DFS).
     - Directed graphs (detect cycles using DFS + recursion stack).

 ✅ Given Data:
 You have:
     - An adjacency list `graph` where `graph.get(i)` returns the list of neighbors of node `i`.
     - The graph may contain multiple disconnected components.
     - For undirected graphs, you must return `true` if any cycle exists.
     - For directed graphs, you must also return `true` if any cycle exists.

 ✅ Intuition:
 - In undirected graphs, a cycle exists when we revisit a node already visited and it’s not the parent.
 - In directed graphs, a cycle exists if a node is revisited in the same DFS recursion path.

 ------------------------------------------------------------
 Approach-1: Undirected Graph - BFS + Parent Map
 ------------------------------------------------------------
 ✅ Idea:
     - Use BFS from each unvisited node.
     - Maintain a parent map to keep track of the node from which each node was discovered.
     - If we encounter a neighbor that’s visited but not the parent → cycle exists.

 ✅ Step-by-step:
     - Step 1: Initialize a `visited[]` array.
     - Step 2: Loop through all nodes:
         - If unvisited, start BFS from the node.
     - Step 3: In BFS:
         - Use a queue to explore nodes level by level.
         - Store each node’s parent in a HashMap.
         - For each neighbor:
             - If it's visited and not the parent → cycle found.
             - If not visited → mark visited, enqueue it, and set its parent.

 ✅ 🔍 Why parent map is needed?
     - In undirected graphs, each edge is bidirectional.
     - So revisiting the parent is valid — it shouldn't be treated as a cycle.
     - Hence we check if the visited neighbor is not the parent.

 🕒 Time Complexity:
     - O(V + E), V = vertices, E = edges.

 🧠 Space Complexity:
     - O(V) for visited array + O(V) for queue + O(V) for parent map.

 ------------------------------------------------------------
 Approach-2: Undirected Graph - DFS + Parent Parameter
 ------------------------------------------------------------
 ✅ Idea:
     - Use DFS from each unvisited node.
     - For each neighbor:
         - If unvisited, recurse with current node as parent.
         - If visited and not parent → cycle found.

 ✅ Step-by-step:
     - Step 1: Initialize `visited[]` array.
     - Step 2: For each unvisited node, call DFS with parent = -1.
     - Step 3: In DFS:
         - Mark node as visited.
         - For each neighbor:
             - If unvisited → call DFS with current node as parent.
             - If visited and not parent → cycle exists.

 ✅ 🔍 Why parent parameter is needed?
     - Prevents false cycle detection from immediate back-edge to parent node.

 🕒 Time Complexity:
     - O(V + E), where V = number of vertices and E = number of edges.

 🧠 Space Complexity:
     - O(V) for visited array + O(V) recursion stack in worst case.

 ------------------------------------------------------------
 Approach-3: Directed Graph - DFS + Recursion Path Tracking
 ------------------------------------------------------------
 ✅ Idea:
     - Use DFS for each unvisited node.
     - Use two arrays:
         → `visited[]` to mark fully processed nodes.
         → `path[]` (aka recursion stack) to track nodes in the current DFS path.
     - If during DFS, you visit a node that is already in the path → cycle detected.

 ✅ Step-by-step:
     - Step 1: Initialize `visited[]` and `path[]` arrays.
     - Step 2: For each unvisited node, call DFS.
     - Step 3: In DFS:
         - Mark node as visited and add it to path.
         - For each neighbor:
             - If not visited → recurse.
             - If visited and in path → cycle exists.
         - After DFS, remove node from path.

 ✅ 🔍 Why recursion path is needed?
     - In directed graphs, cycles can be detected by re-entering the same recursion path (not just visited nodes).
     - A visited node not in current path is not part of a cycle.

 🕒 Time Complexity:
     - O(V + E)

 🧠 Space Complexity:
     - O(V) for visited + O(V) for recursion path stack.

 ✅ Summary:
     - Undirected Graph:
         - Use BFS with parent map or DFS with parent tracking.
     - Directed Graph:
         - Use DFS with recursion path tracking.
