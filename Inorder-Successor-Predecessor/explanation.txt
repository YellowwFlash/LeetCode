 ‚úÖ Problem:
 Given a **Binary Search Tree (BST)** and a target value `key`,
 your task is to find:
   1. The **Inorder Successor**: the smallest node greater than or equal to `key`.
   2. The **Inorder Predecessor**: the largest node less than or equal to `key`.

 ‚úÖ Definitions:
 - **Inorder Successor** of a node is the next node in the in-order traversal (next greater value).
 - **Inorder Predecessor** is the previous node in the in-order traversal (next smaller value).

 ‚úÖ Given Data:
 - A root node of a BST.
 - A target key to compare against.
 - Methods:
     - `successorNode(Node root, int key)` ‚Üí returns successor node.
     - `predecessorNode(Node root, int key)` ‚Üí returns predecessor node.

 ------------------------------------------------------------
 üåê Variation 1: Finding Inorder Successor
 ------------------------------------------------------------

 ‚úÖ Intuition:
 - In a BST, values to the **left are smaller**, and values to the **right are larger**.
 - To find the smallest node ‚â• `key`:
     - Traverse from root.
     - If current node's value ‚â• `key`, store it as a candidate and go left.
     - Otherwise, go right.

 ‚úÖ Steps:
 1. Initialize `successor` as `null`.
 2. While traversing:
     - If `current.data >= key`, it's a potential successor:
         - Store it.
         - Move to the left to try finding a smaller valid node.
     - Else:
         - Move right to find a larger node.
 3. Return the last stored `successor`.

 ‚úÖ Time Complexity:
 - O(h), where h = height of BST.
     - O(log n) for balanced BST.
     - O(n) for skewed BST.

 ‚úÖ Space Complexity:
 - O(1), since only pointers are used.

 ------------------------------------------------------------
 üåê Variation 2: Finding Inorder Predecessor
 ------------------------------------------------------------

 ‚úÖ Intuition:
 - To find the largest node ‚â§ `key`:
     - Traverse from root.
     - If current node's value ‚â§ `key`, store it as a candidate and go right.
     - Otherwise, go left.

 ‚úÖ Steps:
 1. Initialize `predecessor` as `null`.
 2. While traversing:
     - If `current.data <= key`, it's a potential predecessor:
         - Store it.
         - Move to the right to try finding a larger valid node.
     - Else:
         - Move to the left to find a smaller node.
 3. Return the last stored `predecessor`.

 ‚úÖ Time Complexity:
 - O(h), where h = height of BST.

 ‚úÖ Space Complexity:
 - O(1), constant space usage.

 ‚úÖ Example:
 For BST:
         20
        /  \
      10    30
     /  \     \
    5   15     40

 - successorNode(root, 16) ‚Üí 20
 - predecessorNode(root, 16) ‚Üí 15
