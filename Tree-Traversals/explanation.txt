âœ… Tree Traversals Overview:
A binary tree can be traversed in different ways. The major types are:
1. Preorder Traversal (Root â†’ Left â†’ Right)
2. Inorder Traversal (Left â†’ Root â†’ Right)
3. Postorder Traversal (Left â†’ Right â†’ Root)
4. Level-order Traversal (Breadth-First using Queue)

We implement each of them recursively and iteratively where applicable.
Let's walk through each approach below:

---------------------------------------------------------
âœ… Traversal-1: Preorder Traversal (Recursive)
---------------------------------------------------------
Given Function: `preorderTraversal(Node root, List<Integer> list)`

ğŸ” Order Followed: Root â†’ Left â†’ Right

ğŸ§  Approach:
- Start at the root.
- Visit the current node first, then its left subtree, then right subtree.
- This is a depth-first traversal.
- Use recursion to explore left and right subtrees.

ğŸ•’ Time Complexity: O(n)
ğŸ’¾ Space Complexity: O(h), where h = height of the tree (recursion stack)

---------------------------------------------------------
âœ… Variation-1: Preorder Traversal (Iterative)
---------------------------------------------------------
Given Function: `iterativePreorderTraversal(Node root)`

ğŸ“¦ Data Structure: Stack

ğŸ§  Approach:
- Use a stack (LIFO) to mimic the recursive call stack.
- Push root to the stack.
- While stack is not empty:
    - Pop the top node, visit it.
    - Push right child first, then left (so left is processed first).
- This ensures the traversal order remains: Root â†’ Left â†’ Right

ğŸ•’ Time Complexity: O(n)
ğŸ’¾ Space Complexity: O(n) (in worst case when tree is skewed)

---------------------------------------------------------
âœ… Traversal-2: Inorder Traversal (Recursive)
---------------------------------------------------------
Given Function: `inorderTraversal(Node root, List<Integer> list)`

ğŸ” Order Followed: Left â†’ Root â†’ Right

ğŸ§  Approach:
- Recursively explore the left subtree.
- Visit the current node.
- Then explore the right subtree.

ğŸ•’ Time Complexity: O(n)
ğŸ’¾ Space Complexity: O(h) (recursion stack)

---------------------------------------------------------
âœ… Variation-2: Inorder Traversal (Iterative)
---------------------------------------------------------
Given Function: `iterativeInorderTraversal(Node root)`

ğŸ“¦ Data Structure: Stack

ğŸ§  Approach:
- Start with the root.
- Push all left nodes onto the stack.
- When left is done, pop the node, visit it, and then explore the right subtree.
- Repeat until stack is empty and current is null.

ğŸ•’ Time Complexity: O(n)
ğŸ’¾ Space Complexity: O(n)

---------------------------------------------------------
âœ… Traversal-3: Postorder Traversal (Recursive)
---------------------------------------------------------
Given Function: `postorderTraversal(Node root, List<Integer> list)`

ğŸ” Order Followed: Left â†’ Right â†’ Root

ğŸ§  Approach:
- Traverse left subtree, then right subtree.
- Finally, visit the node.
- Useful for deleting trees or evaluating expressions.

ğŸ•’ Time Complexity: O(n)
ğŸ’¾ Space Complexity: O(h)

---------------------------------------------------------
âœ… Variation-3.1: Postorder Traversal using Two Stacks
---------------------------------------------------------
Given Function: `iterativePostorderTraversalTwoStacks(Node root)`

ğŸ“¦ Data Structures: Two stacks (`stack1`, `stack2`)

ğŸ§  Approach:
- Push root to stack1.
- While stack1 is not empty:
    - Pop from stack1 and push to stack2.
    - Push left and right children of the popped node to stack1.
- After stack1 is empty, pop all from stack2 (gives postorder).

âœ… Why Two Stacks?
- stack2 reverses the order to simulate left â†’ right â†’ root.

ğŸ•’ Time Complexity: O(n)
ğŸ’¾ Space Complexity: O(n)

---------------------------------------------------------
âœ… Variation-3.2: Postorder Traversal using One Stack
---------------------------------------------------------
Given Function: `iterativePostorderTraversalOneStack(Node root)`

ğŸ“¦ Data Structure: One stack

ğŸ§  Approach:
- Traverse as deep as possible to the left.
- Keep checking right subtree before visiting node.
- If right child is unvisited, switch to it and repeat.
- Otherwise, visit the node and backtrack.

âœ… Why Use `temp == stack.peek().right`?
- To know whether weâ€™re done visiting the right subtree of the top node.

ğŸ•’ Time Complexity: O(n)
ğŸ’¾ Space Complexity: O(n)

---------------------------------------------------------
âœ… Traversal-4: Level-order Traversal (Recursive)
---------------------------------------------------------
Given Function: `levelorderTraversal(Node root, int level, List<List<Integer>> list)`

ğŸ“¦ Data Structure: List of Lists (result)

ğŸ§  Approach:
- Traverse the tree level by level (starting at level 0).
- Use recursion to track levels.
- When reaching a new level, add a new list to store nodes.
- Add current nodeâ€™s data at its respective level.

ğŸ•’ Time Complexity: O(n)
ğŸ’¾ Space Complexity: O(n) for storing nodes + O(h) for recursion

---------------------------------------------------------
âœ… Variation-4: Level-order Traversal (Iterative - Breadth-First Search)
---------------------------------------------------------
Given Function: `iterativeLevelorderTraversal(Node root)`

ğŸ“¦ Data Structure: Queue (FIFO)

ğŸ§  Approach:
- Add root to the queue.
- For each level:
    - Process all nodes at current level (size of queue).
    - Add left and right children to the queue.
    - Save values of this level into result list.
- Repeat until queue is empty.

âœ… Why Use Queue?
- Ensures we process nodes in level order (FIFO behavior)

ğŸ•’ Time Complexity: O(n)
ğŸ’¾ Space Complexity: O(n) for queue + result list

---------------------------------------------------------
âœ… Final Summary:
---------------------------------------------------------

-----------------------------------------------------------------------------------
Traversal Type   | Recursive Stack | Iterative DS     | Order
----------------|------------------|------------------|----------------------------
Preorder        | Implicit         | Stack            | Root â†’ Left â†’ Right
Inorder         | Implicit         | Stack            | Left â†’ Root â†’ Right
Postorder       | Implicit         | Stack (1/2)      | Left â†’ Right â†’ Root
Level-order     | Queue or Recursion| Queue           | Level by Level (BFS)
