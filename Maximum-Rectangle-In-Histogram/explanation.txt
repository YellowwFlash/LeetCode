âœ… Given Question:
You are given an array `heights` representing the histogram where the width of each bar is 1.
You must find the area of the largest rectangle that can be formed inside the histogram.

âœ… Given Data:
  - `heights`: an array of non-negative integers (e.g., [2,1,5,6,2,3])
  - Each index represents the height of a histogram bar of unit width.
  - Goal: Find the area of the largest rectangle that can be formed using contiguous bars.

âœ… Intuition:
To find the largest rectangle, we try to treat each bar as the "shortest" bar in some rectangle.
We want to expand this rectangle as far as possible to the left and right where bars are at least as tall as the current one.

To do this, we need to find:
  - Previous Smaller Element (PSE): First bar to the left that is smaller than the current bar.
  - Next Smaller Element (NSE): First bar to the right that is smaller than the current bar.

Once we know these two, we can compute:
  âž¤ Width of rectangle = (Right boundary - Left boundary - 1)  
  âž¤ Height of rectangle = height of the current bar (since it's the shortest)

Using a monotonic increasing stack helps us find PSE and NSE efficiently.

------------------------------------------------------
Approach-1: Monotonic Stack (Efficient)
------------------------------------------------------
ðŸ”¹ Method: `maximumRectangle(int[] heights)`
Steps:
  1. Initialize an empty stack to store indices of histogram bars.
     - The stack maintains an increasing order of heights.
  2. Traverse each index `i` in the array:
      - While the current height is less than or equal to the height at the top of the stack:
          - It means the bar at top can't extend beyond this one.
          - So we pop the stack and calculate area:
              âž¤ height = heights[stack[top]] â†’ height of the popped bar
              âž¤ width = (top == -1) ? i : (i - stack[top] - 1)
                - Case 1: Stack is empty â†’ bar extends from 0 to i-1 â†’ width = i
                - Case 2: Stack has elements â†’ bar extends from stack[top] + 1 to i - 1
              âž¤ area = height * width
              âž¤ Update maxArea if area is larger
      - Push current index `i` to the stack
  3. After traversing all bars, we may still have indices in the stack:
      - These bars can extend till the end of the histogram (n - 1)
      - For each, calculate:
          âž¤ height = heights[stack[top]]
          âž¤ width = (top == -1) ? n : (n - stack[top] - 1)
          âž¤ area = height * width
          âž¤ Update maxArea
  4. Return the maximum area found.

âœ… Why This Works:
- The stack helps track previous smaller elements (left boundary).
- When we pop an element, the current index `i` acts as the next smaller element (right boundary).
- This gives us a bounded window where the popped bar is the shortest â€” ideal for rectangle calculation.

âœ… Time Complexity:
  - O(n), where n = number of bars
    Each index is pushed and popped at most once.

âœ… Space Complexity:
  - O(n), for the stack used to store indices.

ðŸ”¹ Example:
    Input: heights = [2, 1, 5, 6, 2, 3]
    Stack Trace:
      - i=0: stack = [0]
      - i=1: height=1 < height[stack.top]=2 â†’ pop 0 â†’ height=2, width=1 â†’ area=2
             stack = [] â†’ push 1
      - i=2: stack = [1,2]
      - i=3: stack = [1,2,3]
      - i=4: height=2 < height[3]=6 â†’ pop 3 â†’ height=6, width=1 â†’ area=6
             height=2 < height[2]=5 â†’ pop 2 â†’ height=5, width=2 â†’ area=10
             stack = [1] â†’ push 4
      - i=5: stack = [1,4,5]
    After loop:
      - pop 5 â†’ height=3, width=1 â†’ area=3
      - pop 4 â†’ height=2, width=4 â†’ area=8
      - pop 1 â†’ height=1, width=6 â†’ area=6
    Max area = 10

ðŸ”¹ Final Summary:
- Why height = heights[stack[top]]?  
  â†’ Thatâ€™s the height of the rectangle, since thatâ€™s the bar being considered as the shortest.

- Why width = (i - stack[top] - 1)?  
  â†’ Because weâ€™re calculating the distance between the next and previous smaller elements:
    - `i` is the current index (next smaller)
    - `stack[top]` is the previous smaller
    - So the valid width is between them: `i - stack[top] - 1`

- Why is the stack increasing?  
  â†’ Because we only pop when we find a shorter bar (which defines the NSE).  
     This ensures each rectangle is processed at the right time, and once.

ðŸ”¹ Edge Cases:
  - If the array is empty â†’ return 0
  - All bars same height â†’ area = height * length
  - Strictly increasing heights â†’ max area found at cleanup phase
  - Strictly decreasing heights â†’ each bar popped immediately, narrow rectangles
