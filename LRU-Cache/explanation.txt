âœ… Given Question:
Design and implement a data structure for Least Recently Used (LRU) Cache.
It should support the following operations:
  âž¤ `get(key)` â€“ Return the value of the key if it exists in the cache, otherwise return -1.
  âž¤ `put(key, value)` â€“ Update or insert the value; if capacity is reached, evict the least recently used item.

âœ… Given Data:
  - A fixed-capacity cache (max number of items it can store)
  - Must support O(1) `get()` and `put()` operations

âœ… Intuition:
To achieve O(1) time complexity for both operations:
  âž¤ Use a HashMap to provide quick access to cache entries by key
  âž¤ Use a Doubly Linked List to maintain the usage order:
     - Most recently used items are at the front (near the head)
     - Least recently used items are at the back (near the tail)
  âž¤ Every time a key is accessed or inserted, move it to the front

This combination allows:
  - Fast lookup with HashMap
  - Fast updates of order with Doubly Linked List

------------------------------------------------------
Implementation Design:
------------------------------------------------------
ðŸ”¹ Class: `LRUCache`
  - Fields:
    â€¢ `map`: HashMap<Integer, Node> â†’ stores key-node pairs for O(1) access
    â€¢ `head`, `tail`: Dummy nodes marking boundaries of the doubly linked list
    â€¢ `capacity`: Maximum number of cache items

ðŸ”¹ Internal Node Class:
  - `Node` contains:
    â€¢ key: for identifying the entry
    â€¢ data: the value stored
    â€¢ prev and next: pointers for the doubly linked list

------------------------------------------------------
ðŸ”¹ Method: `get(int key)`
Steps:
  1. Check if the key exists in the map
     - If not, return -1
  2. Retrieve the node from the map
  3. Move the node to the front (marking it as recently used):
     - Remove from current position
     - Add after head
  4. Return nodeâ€™s data

------------------------------------------------------
ðŸ”¹ Method: `put(int key, int value)`
Steps:
  1. If key exists:
     - Update node's value
     - Move it to the front
  2. If key doesn't exist:
     - If capacity reached, evict least recently used (tail.prev)
     - Create new node and insert at the front

------------------------------------------------------
ðŸ”¹ Method: `deleteNode(Node node)`
Steps:
  - Remove the node from linked list and map:
    â€¢ Adjust prev and next pointers
    â€¢ Remove node.key from the map

ðŸ”¹ Method: `addNode(Node node)`
Steps:
  - Insert node right after the dummy `head`
  - Update pointers
  - Add key-node pair to map

âœ… Time Complexity:
  - O(1) for both `get()` and `put()` due to:
    âž¤ HashMap for lookup
    âž¤ Doubly Linked List for order maintenance

âœ… Space Complexity:
  - O(capacity) for storing up to `capacity` nodes in the cache

ðŸ”¹ Example:
    LRUCache cache = new LRUCache(2);
    cache.put(1, 1);       // Cache: [1]
    cache.put(2, 2);       // Cache: [2, 1]
    cache.get(1);          // Returns 1 â†’ Cache: [1, 2]
    cache.put(3, 3);       // Evicts key 2 â†’ Cache: [3, 1]
    cache.get(2);          // Returns -1 (not found)
    cache.put(4, 4);       // Evicts key 1 â†’ Cache: [4, 3]
    cache.get(1);          // Returns -1
    cache.get(3);          // Returns 3
    cache.get(4);          // Returns 4

ðŸ”¹ Final Summary:
- LRU Cache uses HashMap + Doubly Linked List to achieve O(1) access and eviction.
- Ensures that most recently accessed items stay in cache, while least used items get evicted first.
- Dummy head and tail simplify the list manipulation logic by avoiding null checks.

ðŸ”¹ Edge Cases:
  - Accessing a missing key â†’ returns -1
  - Inserting when cache is full â†’ removes least recently used item
  - Re-inserting existing key â†’ updates and moves it to the front
