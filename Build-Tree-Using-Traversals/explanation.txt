 âœ… Problem:
 You're given the inorder and preorder/postorder traversal of a binary tree.
 Your task is to reconstruct the original binary tree from these traversals.

 ------------------------------------------------------------
 ðŸŒ Approach: Recursive Tree Construction using HashMap
 ------------------------------------------------------------

 âœ… Intuition:
 âž¤ Inorder traversal tells us how nodes are arranged with respect to left and right subtrees.
 âž¤ Preorder/Postorder gives the order of root nodes.
     - In Preorder, the root is the first element.
     - In Postorder, the root is the last element.
 âž¤ Once we find the root in inorder, we can:
     - Identify left and right subtree ranges.
     - Recursively construct left and right subtrees.

 ------------------------------------------------------------
 ðŸ” Variation 1: Build Tree using Inorder + Preorder
 ------------------------------------------------------------

 âœ… Algorithm Steps:
 1. Create a HashMap to store (value -> index) from inorder array for O(1) access.
 2. Start with the first element in preorder â†’ it's the root.
 3. Find this root's index in inorder using the map.
 4. Compute the size of the left subtree: `leftSize = index - inStart`
 5. Recursively build:
     - Left subtree using preorder range: (preStart + 1) to (preStart + leftSize)
     - Right subtree using preorder range: (preStart + leftSize + 1) to preEnd
     - Inorder range is adjusted accordingly.
 6. Return the root node after assigning left and right.

 âœ… DFS Traversal:
 Recursively processes nodes in a top-down preorder manner.

 ðŸ•’ Time Complexity: O(n)
 - Each node is visited once.
 - Map lookup for index is O(1)

 ðŸ§  Space Complexity: O(n)
 - HashMap for storing inorder indices
 - Recursion stack: O(h), where h = height of the tree

 âœ… Example:
   Preorder = [3,9,20,15,7]
   Inorder  = [9,3,15,20,7]

   â†’ Constructed Tree:
           3
          / \
         9  20
            / \
           15  7


 ------------------------------------------------------------
 ðŸ” Variation 2: Build Tree using Inorder + Postorder
 ------------------------------------------------------------

 âœ… Algorithm Steps:
 1. Create a HashMap to store (value -> index) from inorder array.
 2. Start with the last element in postorder â†’ it's the root.
 3. Find this root's index in inorder.
 4. Compute the size of the left subtree: `leftSize = index - inStart`
 5. Recursively build:
     - Left subtree using postorder range: (postStart) to (postStart + leftSize - 1)
     - Right subtree using postorder range: (postStart + leftSize) to (postEnd - 1)
     - Inorder range is adjusted accordingly.
 6. Return the root node.

 âœ… DFS Traversal:
 Recursively processes nodes in a bottom-up postorder manner.

 ðŸ•’ Time Complexity: O(n)
 - Each node is processed once.

 ðŸ§  Space Complexity: O(n)
 - HashMap + recursion stack

 âœ… Example:
   Postorder = [9,15,7,20,3]
   Inorder   = [9,3,15,20,7]

   â†’ Constructed Tree:
           3
          / \
         9  20
            / \
           15  7

