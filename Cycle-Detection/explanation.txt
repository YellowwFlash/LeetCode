 âœ… Given Question:
 You are given a graph represented as an adjacency list (`List<List<Integer>> graph`).
 Your task is to detect whether the graph contains a cycle.

 You need to handle:
     - Undirected graphs (detect cycles using BFS and DFS).
     - Directed graphs (detect cycles using DFS + recursion stack).

 âœ… Given Data:
 You have:
     - An adjacency list `graph` where `graph.get(i)` returns the list of neighbors of node `i`.
     - The graph may contain multiple disconnected components.
     - For undirected graphs, you must return `true` if any cycle exists.
     - For directed graphs, you must also return `true` if any cycle exists.

 âœ… Intuition:
 - In undirected graphs, a cycle exists when we revisit a node already visited and itâ€™s not the parent.
 - In directed graphs, a cycle exists if a node is revisited in the same DFS recursion path.

 ------------------------------------------------------------
 Approach-1: Undirected Graph - BFS + Parent Map
 ------------------------------------------------------------
 âœ… Idea:
     - Use BFS from each unvisited node.
     - Maintain a parent map to keep track of the node from which each node was discovered.
     - If we encounter a neighbor thatâ€™s visited but not the parent â†’ cycle exists.

 âœ… Step-by-step:
     - Step 1: Initialize a `visited[]` array.
     - Step 2: Loop through all nodes:
         - If unvisited, start BFS from the node.
     - Step 3: In BFS:
         - Use a queue to explore nodes level by level.
         - Store each nodeâ€™s parent in a HashMap.
         - For each neighbor:
             - If it's visited and not the parent â†’ cycle found.
             - If not visited â†’ mark visited, enqueue it, and set its parent.

 âœ… ğŸ” Why parent map is needed?
     - In undirected graphs, each edge is bidirectional.
     - So revisiting the parent is valid â€” it shouldn't be treated as a cycle.
     - Hence we check if the visited neighbor is not the parent.

 ğŸ•’ Time Complexity:
     - O(V + E), V = vertices, E = edges.

 ğŸ§  Space Complexity:
     - O(V) for visited array + O(V) for queue + O(V) for parent map.

 ------------------------------------------------------------
 Approach-2: Undirected Graph - DFS + Parent Parameter
 ------------------------------------------------------------
 âœ… Idea:
     - Use DFS from each unvisited node.
     - For each neighbor:
         - If unvisited, recurse with current node as parent.
         - If visited and not parent â†’ cycle found.

 âœ… Step-by-step:
     - Step 1: Initialize `visited[]` array.
     - Step 2: For each unvisited node, call DFS with parent = -1.
     - Step 3: In DFS:
         - Mark node as visited.
         - For each neighbor:
             - If unvisited â†’ call DFS with current node as parent.
             - If visited and not parent â†’ cycle exists.

 âœ… ğŸ” Why parent parameter is needed?
     - Prevents false cycle detection from immediate back-edge to parent node.

 ğŸ•’ Time Complexity:
     - O(V + E), where V = number of vertices and E = number of edges.

 ğŸ§  Space Complexity:
     - O(V) for visited array + O(V) recursion stack in worst case.

 ------------------------------------------------------------
 Approach-3: Directed Graph - DFS + Recursion Path Tracking
 ------------------------------------------------------------
 âœ… Idea:
     - Use DFS for each unvisited node.
     - Use two arrays:
         â†’ `visited[]` to mark fully processed nodes.
         â†’ `path[]` (aka recursion stack) to track nodes in the current DFS path.
     - If during DFS, you visit a node that is already in the path â†’ cycle detected.

 âœ… Step-by-step:
     - Step 1: Initialize `visited[]` and `path[]` arrays.
     - Step 2: For each unvisited node, call DFS.
     - Step 3: In DFS:
         - Mark node as visited and add it to path.
         - For each neighbor:
             - If not visited â†’ recurse.
             - If visited and in path â†’ cycle exists.
         - After DFS, remove node from path.

 âœ… ğŸ” Why recursion path is needed?
     - In directed graphs, cycles can be detected by re-entering the same recursion path (not just visited nodes).
     - A visited node not in current path is not part of a cycle.

 ğŸ•’ Time Complexity:
     - O(V + E)

 ğŸ§  Space Complexity:
     - O(V) for visited + O(V) for recursion path stack.

 âœ… Summary:
     - Undirected Graph:
         - Use BFS with parent map or DFS with parent tracking.
     - Directed Graph:
         - Use DFS with recursion path tracking.
