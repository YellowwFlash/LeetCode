 âœ… Given Question:
 You're given `numCourses` and a list of `prerequisites` where:
     - Each prerequisite is a pair [a, b], meaning course `a` requires course `b` to be completed first.
 
 There are two tasks (variations):

     â¤ Variation-1:
         - Determine if itâ€™s possible to complete **all** courses.
         - Return `true` if yes, otherwise `false`.

     â¤ Variation-2:
         - Return a **valid order** of course completion.
         - If itâ€™s impossible (due to cycle), return an empty list.

 âœ… Given Data:
 You have:
     - An integer `numCourses` representing total courses (0 to numCourses-1).
     - A list of prerequisites.
     - You must use a **BFS-based topological sorting** approach (Kahnâ€™s algorithm):
         - An adjacency list to represent the graph.
         - An `indegree[]` array to track number of prerequisites for each course.
         - A `queue` to process nodes with 0 indegree.

 âœ… Intuition:
 The course dependency graph is a **DAG (if solvable)**:
     - A course can only be taken after its prerequisites are completed.
     - If we can topologically sort all courses â†’ All courses are possible.
     - If a **cycle exists**, at least one course cannot be completed.

 ------------------------------------------------------------
 Variation-1: Check if All Courses Can Be Finished
 ------------------------------------------------------------
     - Step 1: Build the graph:
         - Use an adjacency list `graph` to store prerequisites.
         - Use an `indegree[]` array to count prerequisites for each course.
     - Step 2: Add all courses with indegree 0 to the queue.
     - Step 3: Perform BFS:
         - Remove a course from the queue.
         - Increase a `completed` counter.
         - For each dependent course:
             - Reduce its indegree.
             - If indegree becomes 0, add it to the queue.
     - Step 4: At the end:
         - If `completed == numCourses`, return `true` (all courses possible).
         - Else, return `false` (cycle exists).

 âœ… ğŸ” Deep Dive (isPossible):
     - âœ… Courses with no prerequisites are safe to take first.
     - âœ… BFS reduces the dependency chain layer by layer.
     - âŒ If a course never reaches indegree 0 â†’ part of a cycle â†’ cannot complete all.

 ------------------------------------------------------------
 Variation-2: Return a Valid Course Order
 ------------------------------------------------------------
     - Step 1: Build the graph and indegree array (same as above).
     - Step 2: Enqueue all nodes with indegree 0.
     - Step 3: Perform BFS:
         - Poll a course and add to `order` list.
         - For each dependent course:
             - Decrease indegree.
             - If indegree is 0, enqueue it.
     - Step 4: Final Check:
         - If `order.size() == numCourses` â†’ valid order â†’ return `order`.
         - Else â†’ cycle exists â†’ return empty list.

 âœ… ğŸ” Deep Dive (findOrder):
     - âœ… Maintains correct course execution order.
     - âœ… Any topological ordering is valid if no cycle exists.
     - âŒ If not all nodes are processed, a cycle prevents valid ordering.

 ğŸ•’ Time Complexity (Both Variations):
     - O(V + E) where:
         - V = number of courses (`numCourses`)
         - E = number of prerequisites

 ğŸ§  Space Complexity (Both Variations):
     - O(V + E):
         - For the adjacency list (`graph`) and other helper structures.
